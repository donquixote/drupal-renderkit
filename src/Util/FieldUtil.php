<?php

namespace Drupal\renderkit\Util;

final class FieldUtil extends UtilBase {

  /**
   * @param string $fieldName
   * @param string|null $entityType
   * @param string|null $bundleName
   *
   * @return null|string
   */
  static function fieldnameEtBundleGetLabel($fieldName, $entityType = NULL, $bundleName = NULL) {
    // @todo Maybe this can be done faster?
    $options = self::etBundleGetFieldNameOptions($entityType, $bundleName);
    return isset($options[$fieldName])
      ? $options[$fieldName]
      : NULL;
  }

  /**
   * @param string $fieldName
   * @param string|null $entityType
   * @param string|null $bundleName
   *
   * @return bool
   */
  static function fieldnameEtBundleExists($fieldName, $entityType = NULL, $bundleName = NULL) {
    // @todo Maybe this can be done faster?
    $options = self::etBundleGetFieldNameOptions($entityType, $bundleName);
    return isset($options[$fieldName]);
  }

  /**
   * @param string|null $entityType
   * @param string|null $bundleName
   *
   * @return string[]
   *   Format: $[$fieldName] = $optionLabel
   */
  static function etBundleGetFieldNameOptions($entityType = NULL, $bundleName = NULL) {

    $instancesByFieldAndLabel = self::etBundleGetFieldInstancesByFieldAndLabel($entityType, $bundleName);

    $options = array();
    foreach ($instancesByFieldAndLabel as $fieldName => $fieldInstancesByLabel) {
      $options[$fieldName] = implode(' / ', array_keys($fieldInstancesByLabel)) . ' (' . $fieldName . ')';
    }

    return $options;
  }

  /**
   * @param string|null $expectedEntityType
   * @param string|null $expectedBundleName
   *
   * @return array[][]
   *   Format: $[$fieldName][$instanceFieldLabel][] = array($instanceEntityType, $instanceBundleName)
   */
  static function etBundleGetFieldInstancesByFieldAndLabel($expectedEntityType = NULL, $expectedBundleName = NULL) {

    $instancesByFieldAndLabel = array();
    foreach (self::etBundleGetFieldInstancesByEtBundle($expectedEntityType, $expectedBundleName) as $entityType => $entityTypeInstances) {
      foreach ($entityTypeInstances as $bundleName => $bundleInstances) {
        foreach ($bundleInstances as $fieldName => $instance) {
          $instancesByFieldAndLabel[$fieldName][$instance['label']][] = array($entityType, $bundleName);
        }
      }
    }

    return $instancesByFieldAndLabel;
  }

  /**
   * @param string $entityType
   * @param string $bundleName
   *
   * @return array[][]
   *   Format: $[$entityType][$bundleName] = $fieldInstance
   */
  static function etBundleGetFieldInstancesByEtBundle($entityType = NULL, $bundleName = NULL) {

    $cache = _field_info_field_cache();
    if (NULL === $entityType) {
      $instances = $cache->getInstances();
    }
    elseif (NULL === $bundleName) {
      $instances[$entityType] = $cache->getInstances($entityType);
    }
    else {
      $instances[$entityType][$bundleName] = $cache->getBundleInstances($entityType, $bundleName);
    }

    return $instances;
  }

  /**
   * @param string $fieldType
   *
   * @return array[]
   */
  static function fieldTypeGetAvailableFormatterTypes($fieldType) {
    $availableFormatterTypes = array();
    foreach (field_info_formatter_types() as $formatterTypeName => $formatterTypeDefinition) {
      if (!in_array($fieldType, $formatterTypeDefinition['field types'], TRUE)) {
        continue;
      }
      $availableFormatterTypes[$formatterTypeName] = $formatterTypeDefinition;
    }
    return $availableFormatterTypes;
  }

  /**
   * @param string $formatterTypeName
   *
   * @return string|null
   */
  static function fieldFormatterTypeGetLabel($formatterTypeName) {
    $formatterTypeDefinition = field_info_formatter_types($formatterTypeName);
    if (!isset($formatterTypeDefinition)) {
      return NULL;
    }
    return isset($formatterTypeDefinition['label'])
      ? $formatterTypeDefinition['label']
      : $formatterTypeName;
  }

  /**
   * @param string $formatterTypeName
   *
   * @return bool
   */
  static function fieldFormatterTypeExists($formatterTypeName) {
    $formatterTypeDefinition = field_info_formatter_types($formatterTypeName);
    return isset($formatterTypeDefinition);
  }

  /**
   * Fake an instance of a field.
   *
   * @param string $fieldName
   *   The unique name for this field no matter what entity/bundle it may be used on.
   * @param string $viewMode
   *   We're building a new view mode for this function.  Defaults to ctools, but we expect developers to actually name this something meaningful.
   * @param string $formatterTypeName
   *   The formatter key selected from the options provided by field_ui_formatter_options().
   * @param array $formatterSettings
   *   An array of key value pairs.  These will be used as #default_value for the form elements generated by a call to hook_field_formatter_settings_form() for this field type.
   *   Typically we'll pass an empty array to begin with and then pass this information back to ourselves on form submit so that we can set the values for later edit sessions.
   *
   * @return array
   *
   * @see ctools_fields_fake_field_instance()
   *   Simply copying this to avoid a dependency.
   */
  static function createFakeFieldInstance($fieldName, $viewMode, $formatterTypeName, $formatterSettings) {
    $field = field_read_field($fieldName);

    $field_type = field_info_field_types($field['type']);

    return array(
      // Build a fake entity type and bundle.
      'field_name' => $fieldName,
      'entity_type' => 'ctools',
      'bundle' => 'ctools',

      // Use the default field settings for settings and widget.
      'settings' => field_info_instance_settings($field['type']),
      'widget' => array(
        'type' => $field_type['default_widget'],
        'settings' => array(),
      ),

      // Build a dummy display mode.
      'display' => array(
        $viewMode => array(
          'type' => $formatterTypeName,
          'settings' => $formatterSettings,
        ),
      ),

      // Set the other fields to their default values.
      // @see _field_write_instance().
      'required' => FALSE,
      'label' => $fieldName,
      'description' => '',
      'deleted' => 0,
    );
  }

  /**
   * @param string[] $allowedFieldTypes
   *   (optional) Allowed field types.
   * @param string $entityType
   *   (optional) An entity type, e.g. "node".
   * @param string $bundleName
   *   (optional) The bundle name, e.g. "article".
   *
   * @return string[]
   *   Format: $[$fieldName] = $optionLabel
   */
  static function fieldTypesGetFieldNameOptions(array $allowedFieldTypes = NULL, $entityType = NULL, $bundleName = NULL) {

    $optionsAll = self::etBundleGetFieldNameOptions($entityType, $bundleName);

    $knownFieldTypes = field_info_field_types();

    $fields = field_info_fields();
    $options = array();
    foreach ($optionsAll as $fieldName => $optionLabel) {
      if (isset($fields[$fieldName]['type'])) {
        $fieldTypeName = $fields[$fieldName]['type'];
        if (isset($allowedFieldTypes) && !in_array($fieldTypeName, $allowedFieldTypes, TRUE)) {
          continue;
        }
        if (isset($knownFieldTypes[$fieldTypeName]['label'])) {
          $fieldTypeLabel = $knownFieldTypes[$fieldTypeName]['label'];
        }
        elseif (isset($knownFieldTypes[$fieldTypeName])) {
          $fieldTypeLabel = $fieldTypeName;
        }
        else {
          $fieldTypeLabel = t('Unknown field type.');
        }
        $options[$fieldTypeLabel][$fieldName] = $optionLabel;
      }
      else {
        if (isset($allowedFieldTypes)) {
          continue;
        }
        $options[$fieldName] = $optionLabel;
      }
    }

    return $options;
  }

}
